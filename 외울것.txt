★단축키
- shift+alt+f = prettier 자동정렬
- ctrl + ? = 해당블록주석

★설정
- src와 동일한 디렉토리에 .prettierrc 파일을 생성후 아래처럼 입력
{
        "singleQuote": true,
        "semi": true,
        "useTabs": false,
        "tabWidth": 4
}
- 저장할때마다 자동 들여쓰기 : 파일 > 기본설정 > 설정 > 검색박스에 format on save 검색해서, 체크

★규칙
- 컴포넌트에서 undefined 를 반환하면, 에러난다. jsx 에서 undefined를 출력하는 것은 괜찮다.
- jsx에서 닫는 태그가 없는 경우나, 자식요소가 없는 빈 태그는 셀프클로저를 사용하면 된다.
- 클래스형 컴포넌트는 render() 함수가 꼭 있어야 하고, jsx를 반환해야 한다.
- 클래스형 컴포넌트는 state, 라이프사이클기능을 사용할 수 있고, 임의 메서드를 정의할 수 있다. 함수형에서는 못쓰지만, hooks를 통해 비슷하게 구현할 수 있다.
- 클래스형 컴포넌트의 state 초기값은 객체형식이어야 한다. setState 로 업데이트가 가능하다.
- 함수형에서 state를 사용하려면, useState 를 사용한다. 초기값은 객체가 아니어도 된다.
- props로 받아온 값은 컴포넌트가 읽기만 가능하고, 변경할 수 없다. 값을 변경할때는 state, setState를 사용한다. 함수형은 useState
- setState 두번째 인자로 함수를 추가하면, setState가 끝난후 동작을 추가할 수 있다.
- propTypes 종류 : array, arrayOf, bool, func, number, object, string, symbol, node, instanceOf, oneOf, oneOfType, objectOf, shape, any
- render 에서는 아무것도 반환할게 없으면, false 나 null을 반환해야 함
- 배열이나 객체에 대한 업데이트를 하려면, 사본을 만들어서 사본에 업데이트 한다.
- 이벤트는 돔 요소에만 설정할 수 있고, 컴포넌트에는 설정할 수 없다.
- 이벤트 실행후, 일정 시간이 흐르고, 이후 실행되는 함수에서 e 객체를 참조할 일이 있으면, e.persist(); 함수를 한줄 써줘야 한다.
- 메서드 바인딩은 생성자에서 하는게 정석이나, 바벨에서 transform-class-properties 문법을 사용하여 화살표 함수 형태로 메서드를 정의할수 있다.
- dom에 값을 주거나 변경하는 것은 state, props 로 가능하지만 dom을 조작할때는 ref를 사용한다. input에 포커스, 스크롤박스 조작, canvas 그림그리기 등...
- 콜백으로 ref 설정 : <input ref={(ref) => {this.명칭 = ref}} /> 했을때, this.명칭은 해당 dom 요소를 가리킨다. 결과 <input ref={this.명칭}> 이 되므로, 어떤 이벤트 호출부에서 this.명칭.focus() 와 같은 수행이 가능해진다.
- 16.3 이후 버전에서 createRef 를 사용하는데, 편한 방법으로 사용하면 된다.
- 컴포넌트에도 ref를 달 수 있다. 컴포넌트 외부에서 내부에 있는 dom에 접근할때 쓴다. dom과 동일하게 설정하면 된다.
- 컴포넌트에 ref를 달면, 내부의 이벤트나 dom에 접근할 수 있다. (myComponent.handleClick , myComponent.wrapElement 식으로...)
- 서로 다른 컴포넌트끼리 ref를 통해 데이터를 전달하지 말 것. 잡채된다.
- 비구조화 문법은 es6 에서 도입된 문법이다. (babel 환경 또는 es6 지원되는 브라우저에서만 사용할것)
- 배열.map() 은 es5에 도입되었는데, 콜백 뒤에 붙는 파라미터는 어케쓰는지 모르겠다.
- map() 은 새로운 배열로 재구성해서 새로운 변수에 할당하기 때문에, 값을 변경하더라도 참조 방식이 아니므로 원본에 변경이 일어나지 않는다.





